@page "/"
@inject ProjectHermes.ShoppingList.Frontend.Infrastructure.Connection.IApiClient apiClient;
@inject ProjectHermes.ShoppingList.Frontend.Infrastructure.Connection.ICommandQueue commandQueue;
@inject ProjectHermes.ShoppingList.Frontend.WebApp.Service.IShoppingListNotificationService notificationService;
@inject IWebAssemblyHostEnvironment Env;
@using Microsoft.AspNetCore.Components.WebAssembly.Hosting;
@using ProjectHermes.ShoppingList.Frontend.WebApp.Components.Index;
@using ProjectHermes.ShoppingList.Frontend.Models;
@using ProjectHermes.ShoppingList.Frontend.Models.Index;
@using ProjectHermes.ShoppingList.Frontend.Models.Index.Search;
@using ProjectHermes.ShoppingList.Frontend.Models.Shared.Requests;
@using OneOf;
@using ProjectHermes.ShoppingList.Frontend.Models.Shared;

<div>
    <div class="mb-1 d-flex justify-content-end align-items-center">
        <div class="pr-2">
            <Switch Checked="@isDebug" CheckedChildren="Dbg" UnCheckedChildren="Dbg" OnChange="@OnDebugStateChanged" />
        </div>
        <Select Class="mr-1 min-w-100"
                OnChange="@OnSelectedStoreChanged"
                @ref="@storeSelect">
            @foreach (var store in availableStores?.Stores ?? Enumerable.Empty<Store>().ToList())
            {
                <SelectOption Value=@store.Id.ToString() Class="min-w-100">@store.Name</SelectOption>
            }
        </Select>
        <Button Class="mr-1 d-flex align-items-center"
                OnClick="@OnShowBasketItemsChangeButtonClicked"
                Disabled="@(!shoppingList?.AnyItemInBasket ?? true)">
            @if (showItemsInBasket)
            {
                <Icon Type="eye" />
            }
            else
            {
                <Icon Type="eye-invisible" />
            }
        </Button>
        <Button class="mr-1 d-flex align-items-center" OnClick="@OnEditModeButtonClicked"
                Disabled="@(shoppingList.Store == null)">
            <Icon Type="edit" />
        </Button>
    </div>
    <!--search bar-->
    <div class="mb-2 d-flex">
        <Select @ref="@searchSelect"
                OnFocus="OnSearchBarFocusIn"
                Class="@(searchBar.Active ? "ml-1 mr-2 w-100 cursor-text" : "mx-1 w-100 cursor-text")"
                OnSearch="@OnSearchBarInput"
                ShowSearch="true"
                AllowClear="true"
                AutoClearSearchValue="true"
                OnChange="@OnSearchItemSelected">
            @foreach (var option in searchBar.Options)
            {
                <SelectOption Value="@option.ItemId.ToString()">
                    @option.Name | @option.ManufacturerName | @option.Price@option.PriceLabel
                </SelectOption>
            }
        </Select>

        @if (searchBar.Active)
        {
            <Button Type="@ButtonType.Primary" OnClick="@OnCreateNewTemporaryItem">
                <Icon Type="plus"></Icon>
            </Button>
            <Button Class="mr-1" OnClick="@OnSearchBarCancleButtonClicked">Cancle</Button>
        }
    </div>
    <ul class="p-0">
        @foreach (var item in shoppingList.Items.Where(item => showItemsInBasket || !item.IsInBasket))
        {
            <ShoppingListItemComponent Item="@item"
                                       ItemBasketStatusChangedCallback="@OnItemBasketStatusChangedAsync"
                                       ItemQuantityChangedCallback="@OnItemQuantityChangedAsync"
                                       ItemRemovedCallback="@OnItemRemovedFromListAsync"
                                       IsInEditMode="@isInEditMode"></ShoppingListItemComponent>
        }
    </ul>
    <div class="d-flex justify-content-end">
        <Button Type="primary"
                OnClick="@OnFinishListButtonClicked"
                Class="mr-2"
                Disabled="@(!shoppingList?.AnyItemInBasket ?? true)">
            Finish List
        </Button>
    </div>
    <div>
        @foreach (var s in errorMsg)
        {
            <div>@s</div>
        }
    </div>
</div>

@code{
    private bool isDebug = false;

    private ShoppingListRoot shoppingList = new ShoppingListRoot(0, null, null, Enumerable.Empty<ShoppingListItem>());
    private AvailableStores availableStores = new AvailableStores(Enumerable.Empty<Store>());

    private SearchBar searchBar = new SearchBar();
    private Select searchSelect;
    private Select storeSelect;

    private bool isInEditMode = false;
    private bool showItemsInBasket = true;

    private List<string> errorMsg = new List<string>();

    List<ShoppingListItem> items = new List<ShoppingListItem>();

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        isDebug = Env.IsDevelopment();

        commandQueue.Initialize(OnConnectionFailed, OnQueueProcessed, AddToError);

        StateHasChanged();
    }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        try
        {
            await LoadPage();
        }
        catch (Exception e)
        {
            notificationService.NotifyError("Page loading failed", e.Message,
                GetAsyncButtonRenderFragment(
                    async (items) => await LoadPage(),
                    new object[0]));
            AddToError(e.ToString());
            return;
        }
    }

    private int AddToError(string e)
    {
        if (!isDebug)
            return 0;

        errorMsg.Add(e);
        Console.WriteLine(e);
        StateHasChanged();
        return 0;
    }

    private void ResetEditMode()
    {
        isInEditMode = false;
    }

    #region Loading

    private async Task LoadPage()
    {
        await LoadAvailableStoresAsync();
        if (availableStores.Stores.Any())
        {
            availableStores.SetSelectedStore(availableStores.Stores.First().Id);

            // this call is not awaited to give Blazor time to render the SelectOptions
            // of the store-Select. Otherwise an exception is thrown because the store-Select
            // doesn't have any SelectOptions but sets a value
            storeSelect.ToggleOrSetValue(availableStores.SelectedStore.Id.ToString());
        }
    }

    private async Task LoadAvailableStoresAsync()
    {
        List<Store> stores = (await apiClient.GetAllActiveStoresAsync())
            .ToList();

        availableStores = new AvailableStores(stores);
        Console.WriteLine($"{availableStores.Stores.Count} stores loaded");
    }

    private async Task LoadShoppingListAsync()
    {
        try
        {
            shoppingList = await apiClient.GetActiveShoppingListByStoreIdAsync(availableStores.SelectedStore.Id);
            Console.WriteLine($"Loaded shopping list with {shoppingList.Items.Count} items");
        }
        catch (Exception e)
        {
            throw;
        }

        StateHasChanged();
    }
    #endregion

    #region Callbacks
    private void OnDebugStateChanged(bool active)
    {
        isDebug = active;
    }

    private void OnCreateNewTemporaryItem()
    {
        var quantityType = new QuantityType(0, "", 1, "€", "x");
        var quantityTypeInPacket = new QuantityTypeInPacket(0, "", "");
        var item = new ShoppingListItem(new ItemId(Guid.NewGuid()), searchBar.Input, true, 1f, quantityType, 1,
        quantityTypeInPacket, "", "", false, 1);

        var createRequest = new CreateTemporaryItemRequest(Guid.NewGuid(), item.Id.OfflineId.Value, item.Name, shoppingList.Store.Id, item.PricePerQuantity);
        var addRequest = new AddItemToShoppingListRequest(Guid.NewGuid(), shoppingList.Id, item.Id, item.Quantity);
        commandQueue.Enqueue(createRequest);
        commandQueue.Enqueue(addRequest);

        shoppingList.Items.Add(item);
        StateHasChanged();
    }

    private Task OnConnectionFailed()
    {
        AddToError("Connection failed");
        notificationService.NotifyWarning("Connection interrupted", "Connection to the server was interrupted.");
        return Task.CompletedTask;
    }

    private async Task OnQueueProcessed()
    {
        AddToError("Queue processed");
        notificationService.NotifySuccess("Sync successful", "Synchronization with the server was successful.");
        await LoadShoppingListAsync();
    }

    private async void OnSelectedStoreChanged(
    OneOf<string, IEnumerable<string>, LabeledValue, IEnumerable<LabeledValue>> value,
    OneOf<SelectOption, IEnumerable<SelectOption>> option)
    {
        int storeId = int.Parse(value.AsT0);
        availableStores.SetSelectedStore(storeId);
        ResetEditMode();
        await LoadShoppingListAsync();
    }

    private void OnEditModeButtonClicked()
    {
        isInEditMode = !isInEditMode;
        StateHasChanged();
    }

    private void OnShowBasketItemsChangeButtonClicked()
    {
        showItemsInBasket = !showItemsInBasket;
        StateHasChanged();
    }

    private void OnSearchBarFocusIn()
    {
        searchBar.Active = true;
        StateHasChanged();
    }

    private void OnSearchBarCancleButtonClicked()
    {
        searchBar.Active = false;
        StateHasChanged();
    }

    private void OnSearchBarInput(string searchInput)
    {
        if (shoppingList.Store == null)
            return;

        if (string.IsNullOrWhiteSpace(searchInput))
        {
            searchBar.Options = Enumerable.Empty<ItemSearchResult>();
            return;
        }

        searchInput = searchInput.Trim();
        searchBar.Input = searchInput;

        try
        {
            var result =
                apiClient.GetItemSearchResultsAsync(searchInput, shoppingList.Store.Id)
                .GetAwaiter().GetResult();
            searchBar.Options = result;
        }
        catch (Exception e)
        {
            notificationService.NotifyError("Search for items failed", e.Message,
                GetButtonRenderFragment(
                    (items) => OnSearchBarInput((string)items[0]),
                    new object[] { searchInput }));
            AddToError(e.ToString());
            return;
        }
        StateHasChanged();
    }

    private async void OnSearchItemSelected(
        OneOf<string, IEnumerable<string>, LabeledValue, IEnumerable<LabeledValue>> value,
        OneOf<SelectOption, IEnumerable<SelectOption>> option)
    {
        if (value.AsT0 == null)
            return;

        var itemId = int.Parse(value.AsT0);
        var request = new AddItemToShoppingListRequest(Guid.NewGuid(), shoppingList.Id, new ItemId(itemId), 1); //todo default item quantity
        try
        {
            await apiClient.AddItemToShoppingListAsync(request);
        }
        catch (Exception e)
        {
            notificationService.NotifyError("Adding item failed", e.Message);
            AddToError(e.ToString());
            return;
        }

        searchBar.ResetInput();
        searchBar.ResetOptions();
        await searchSelect.ClearAll();

        await LoadShoppingListAsync();
        StateHasChanged();
    }

    private async Task OnItemBasketStatusChangedAsync(ShoppingListItem item)
    {
        if (item.IsInBasket)
        {
            item.RemoveFromBasket();
            var request = new RemoveItemFromBasketRequest(Guid.NewGuid(), shoppingList.Id, item.Id);
            await commandQueue.Enqueue(request);
        }
        else
        {
            item.PutInBasket();
            var request = new PutItemInBasketRequest(Guid.NewGuid(), shoppingList.Id, item.Id);
            await commandQueue.Enqueue(request);
        }
    }

    private async Task OnItemRemovedFromListAsync(ShoppingListItem item)
    {
        var request = new RemoveItemFromShoppingListRequest(Guid.NewGuid(), shoppingList.Id, item.Id);
        await commandQueue.Enqueue(request);
    }

    private async Task OnItemQuantityChangedAsync(ShoppingListItem item)
    {
        var request = new ChangeItemQuantityOnShoppingListRequest(Guid.NewGuid(), shoppingList.Id, item.Id,
        item.Quantity);
        await commandQueue.Enqueue(request);
    }

    private async void OnFinishListButtonClicked()
    {
        var requst = new FinishListRequest(Guid.NewGuid(), shoppingList.Id);
        await commandQueue.Enqueue(requst);
    }
    #endregion

    private RenderFragment GetButtonRenderFragment(Action<object[]> callback, object[] args, string label = "Retry")
    {
        return@<Button Type="@ButtonType.Primary" OnClick="() => callback(args)">@label</Button>;
}

private RenderFragment GetAsyncButtonRenderFragment(Func<object[], Task> callback, object[] args, string label = "Retry")
{
return@<Button Type="@ButtonType.Primary" OnClick="async () => await callback(args)">@label</Button>;
}
}