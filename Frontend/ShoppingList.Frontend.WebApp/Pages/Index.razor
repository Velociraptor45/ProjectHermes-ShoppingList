@page "/"
@inject ProjectHermes.ShoppingList.Frontend.Infrastructure.Connection.IApiClient apiClient;
@inject ProjectHermes.ShoppingList.Frontend.Infrastructure.Connection.ICommandQueue commandQueue;
@inject ProjectHermes.ShoppingList.Frontend.WebApp.Service.IShoppingListNotificationService notificationService;
@inject ProjectHermes.ShoppingList.Frontend.WebApp.Service.IItemPriceCalculationService itemPriceCalculationService;
@inject IWebAssemblyHostEnvironment Env;
@using Microsoft.AspNetCore.Components.WebAssembly.Hosting;
@using ProjectHermes.ShoppingList.Frontend.WebApp.Components.Index;
@using ProjectHermes.ShoppingList.Frontend.WebApp.Components.Common
@using ProjectHermes.ShoppingList.Frontend.Models;
@using ProjectHermes.ShoppingList.Frontend.Models.Shared.Requests;

<div>
    @if (hasProcessingError)
    {
        <ProcessingError ReloadCallback="@ReloadAfterProcessingErrorAsync"></ProcessingError>
    }
    <div class="mb-1 d-flex justify-content-end align-items-center">
        <div class="pr-2">
            <Switch Checked="@isDebug" CheckedChildren="Dbg" UnCheckedChildren="Dbg" OnChange="@OnDebugStateChanged" />
        </div>
        <StoreSelect OnSelectedStoreChangedAsync="@OnSelectedStoreChangedAsync"
                     CreateRenderFragment="@GetButtonRenderFragment"
                     ErrorCallback="AddToError"></StoreSelect>
        <Button Class="mr-1 d-flex align-items-center"
                OnClick="@OnShowBasketItemsChangeButtonClicked"
                Disabled="@(!shoppingList?.AnyItemInBasket ?? true)">
            @if (showItemsInBasket)
            {
                <Icon Type="eye" />
            }
            else
            {
                <Icon Type="eye-invisible" />
            }
        </Button>
        <Button class="mr-1 d-flex align-items-center" OnClick="@OnEditModeButtonClicked"
                Disabled="@(shoppingList.Store == null)">
            <Icon Type="edit" />
        </Button>
    </div>
    <!--search bar-->
    <ItemSearchBar ShoppingList="@shoppingList"
                   ReloadShoppingListAsync="@ReloadShoppingList"
                   UpdateParentState="@StateHasChanged"
                   CreateRenderFragment="@GetButtonRenderFragment"
                   ErrorCallback="AddToError"></ItemSearchBar>
    <div>
        @foreach (var section in shoppingList.Sections.Where(s => s.Items.Any()))
        {
            <Section Model="@section"
                     ShowItemsInBasket="@showItemsInBasket"
                     ItemBasketStatusChangedCallback="@OnItemBasketStatusChangedAsync"
                     ItemQuantityChangedCallback="@OnItemQuantityChangedAsync"
                     ItemRemovedCallback="@OnItemRemovedFromListAsync"
                     IsInEditMode="@isInEditMode"
                     ItemPriceCalculationService="@itemPriceCalculationService"></Section>
        }
    </div>
    <div class="d-flex justify-content-end">
        <Button Type="@ButtonType.Primary"
                OnClick="@OnFinishListButtonClicked"
                Class="mr-2"
                Disabled="@(!shoppingList?.AnyItemInBasket ?? true)">
            Finish List
        </Button>
    </div>
    <div>
        @foreach (var s in errorMsg)
        {
            <div>@s</div>
        }
    </div>
</div>

@code{
    private bool hasProcessingError = false;
    private bool isDebug = false;

    private ShoppingListRoot shoppingList = new ShoppingListRoot(0, null, null, Enumerable.Empty<ShoppingListSection>());

    private bool isInEditMode = false;
    private bool showItemsInBasket = true;

    private List<string> errorMsg = new List<string>();

    List<ShoppingListItem> items = new List<ShoppingListItem>();

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        isDebug = Env.IsDevelopment();

        await itemPriceCalculationService.InitializeAsync();
        commandQueue.Initialize(OnConnectionFailed, OnQueueProcessed, OnApiProcessingError, AddToError);

        StateHasChanged();
    }

    private void AddToError(string e)
    {
        if (!isDebug)
            return;

        errorMsg.Add(e);
        Console.WriteLine(e);
        StateHasChanged();
    }

    private void ResetEditMode()
    {
        isInEditMode = false;
    }

    #region Loading

    private async Task ReloadShoppingList()
    {
        await LoadShoppingListAsync(shoppingList.Store.Id);
    }

    private async Task LoadShoppingListAsync(int storeId)
    {
        try
        {
            shoppingList = await apiClient.GetActiveShoppingListByStoreIdAsync(storeId);
            Console.WriteLine($"Loaded shopping list with {shoppingList.Items.Count} items");
        }
        catch (Exception e)
        {
            throw;
        }

        StateHasChanged();
    }
    #endregion

    #region Callbacks
    private void OnDebugStateChanged(bool active)
    {
        isDebug = active;
    }

    private Task OnConnectionFailed()
    {
        AddToError("Connection failed");
        notificationService.NotifyWarning("Connection interrupted", "Connection to the server was interrupted.");
        return Task.CompletedTask;
    }

    private async Task OnQueueProcessed()
    {
        AddToError("Queue processed");
        notificationService.NotifySuccess("Sync successful", "Synchronization with the server was successful.");
        await ReloadShoppingList();
    }

    private void OnApiProcessingError()
    {
        hasProcessingError = true;
    }

    private async Task OnSelectedStoreChangedAsync(Store store)
    {
        ResetEditMode();
        await LoadShoppingListAsync(store.Id);
    }

    private void OnEditModeButtonClicked()
    {
        isInEditMode = !isInEditMode;
        StateHasChanged();
    }

    private void OnShowBasketItemsChangeButtonClicked()
    {
        showItemsInBasket = !showItemsInBasket;
        StateHasChanged();
    }

    private async Task OnItemBasketStatusChangedAsync(ShoppingListItem item)
    {
        if (item.IsInBasket)
        {
            item.RemoveFromBasket();
            var request = new RemoveItemFromBasketRequest(Guid.NewGuid(), shoppingList.Id, item.Id);
            await commandQueue.Enqueue(request);
        }
        else
        {
            item.PutInBasket();
            var request = new PutItemInBasketRequest(Guid.NewGuid(), shoppingList.Id, item.Id);
            await commandQueue.Enqueue(request);
        }
    }

    private async Task OnItemRemovedFromListAsync(ShoppingListItem item)
    {
        shoppingList.Remove(item.Id);
        var request = new RemoveItemFromShoppingListRequest(Guid.NewGuid(), shoppingList.Id, item.Id);
        await commandQueue.Enqueue(request);
    }

    private async Task OnItemQuantityChangedAsync(ShoppingListItem item)
    {
        var request = new ChangeItemQuantityOnShoppingListRequest(Guid.NewGuid(), shoppingList.Id, item.Id,
        item.Quantity);
        await commandQueue.Enqueue(request);
    }

    private async void OnFinishListButtonClicked()
    {
        var request = new FinishListRequest(Guid.NewGuid(), shoppingList.Id);
        await apiClient.FinishListAsync(request);
        await ReloadShoppingList();
    }
    #endregion

    private async Task ReloadAfterProcessingErrorAsync()
    {
        hasProcessingError = false;
        await ReloadShoppingList();
    }

    private RenderFragment GetButtonRenderFragment(Action<object[]> callback, object[] args, string label = "Retry")
    {
        return@<Button Type="@ButtonType.Primary" OnClick="() => callback(args)">@label</Button>;
}

private RenderFragment GetAsyncButtonRenderFragment(Func<object[], Task> callback, object[] args, string label = "Retry")
{
return@<Button Type="@ButtonType.Primary" OnClick="async () => await callback(args)">@label</Button>;
}
}