@inherits Fluxor.Blazor.Web.Components.FluxorComponent

@using Fluxor
@using global::ShoppingList.Frontend.Redux.Items.Actions
@using global::ShoppingList.Frontend.Redux.Items.Actions.Editor
@using global::ShoppingList.Frontend.Redux.Items.Actions.Editor.Availabilities
@using global::ShoppingList.Frontend.Redux.Items.States

@inject IState<ItemState> State
@inject IDispatcher Dispatcher

@using ProjectHermes.ShoppingList.Frontend.Models.Items;
@using ProjectHermes.ShoppingList.Frontend.Models.Items.Models
@using ProjectHermes.ShoppingList.Frontend.WebApp.Pages.Items.Models

<div>
    <div class="mt-3 d-flex justify-content-start align-items-center">
        <div class="font-weight-bold mr-2">Stores</div>
        <Button class="d-flex align-items-center" Size="@AntSizeLDSType.Small" OnClick="OnAddStoreButtonClicked"
                Disabled="@(!Available.GetNotRegisteredStores(State.Value.Stores.Stores).Any())">
            <Icon Type="plus"></Icon>
        </Button>
    </div>
    <div class="py-2">
        @foreach(var availability in Available.Availabilities)
        {
            <div class="pb-3">
                <Availability Available="Available" Model="@availability"></Availability>
            </div>
        }
    </div>
</div>

@code {
    [Parameter] public IAvailable Available { get; set; }
    
    //private List<List<AvailabilityStore>> _storesPerAvailability;

    //protected override void OnInitialized()
    //{
    //    base.OnInitialized();
    //    BuildDict();
    //}

    private void OnAddStoreButtonClicked()
    {
        //Available.AddStore(State.Stores);
        //AddStoreAvailability(Available.Availabilities.Count - 1);
        //UpdateAvailabilityStoreDisabling();

        //State.StateChanged();

        Dispatcher.Dispatch(new AddStoreAction(Available));
    }

    //private void BuildDict()
    //{
    //    _storesPerAvailability = new();

    //    for (int i = 0; i < Available.Availabilities.Count; i++)
    //    {
    //        AddStoreAvailability(i);
    //    }
    //    UpdateAvailabilityStoreDisabling();
    //}

    //private void AddStoreAvailability(int index)
    //{
    //    var stores = State.Stores
    //        .Select(s => new AvailabilityStore(s.Id, s.Name, false))
    //        .ToList();
    //    _storesPerAvailability.Insert(index, stores);
    //}

    //public void UpdateAvailabilityStoreDisabling()
    //{
    //    var availableStores = Available
    //        .GetNotRegisteredStores(State.Stores)
    //        .Select(s => s.Id)
    //        .ToHashSet();

    //    for (int i = 0; i < Available.Availabilities.Count; i++)
    //    {
    //        var availability = Available.Availabilities[i];
    //        var stores = _storesPerAvailability[i];

    //        foreach (var store in stores)
    //        {
    //            store.IsDisabled = store.Id != availability.Store.Id && !availableStores.Contains(store.Id);
    //        }
    //    }
    //}

    //private void OnRemoveAvailability(int index)
    //{
    //    Available.Availabilities.RemoveAt(index);
    //    _storesPerAvailability.RemoveAt(index);
    //    UpdateAvailabilityStoreDisabling();
    //    StateHasChanged();
    //}

    //private void OnSelectedStoreInAvailabilityChanged()
    //{
    //    UpdateAvailabilityStoreDisabling();
    //    StateHasChanged();
    //}
}