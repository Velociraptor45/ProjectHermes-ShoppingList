@inherits Fluxor.Blazor.Web.Components.FluxorComponent

@using ProjectHermes.ShoppingList.Frontend.WebApp.Pages.Index.Models
@using ProjectHermes.ShoppingList.Frontend.WebApp.Pages.Index.Services
@using ProjectHermes.ShoppingList.Frontend.Models
@using ProjectHermes.ShoppingList.Frontend.Models.ShoppingLists.Services
@using System.Text.RegularExpressions
@using Fluxor
@using global::ShoppingList.Frontend.Redux.ShoppingList.Actions
@using global::ShoppingList.Frontend.Redux.ShoppingList.States
@using ShoppingListState = global::ShoppingList.Frontend.Redux.ShoppingList.States.ShoppingListState

@inject NavigationManager _navigationManager;
@inject IItemPriceCalculationService _itemPriceCalculationService;
@inject IShoppingListApiService _apiService;

@inject IState<ShoppingListState> State
@inject IDispatcher Dispatcher

<li class="item py-2 mb-1 @(Model.IsInBasket ? "green-bg" : "red-bg") white" @onclick="OnItemClickedAsync">
    @if (State.Value.EditModeActive)
    {
        <div class="d-flex flex-column ml-2">
            <div class="d-flex">
                <!-- upper row -->
                <div class="h3 pl-1">@Model.Name</div>
                <Button Danger="true"
                        Icon="close"
                        Class="mr-2 ml-auto d-flex align-items-center justify-content-center"
                        OnClick="@OnRemoveItemButtonClickedAsync"></Button>
            </div>
            <div>
                <!-- lower row -->
                <div class="d-flex">
                    <div class="d-flex">
                        <div class="d-flex mr-3">
                            <AntDesign.InputNumber Value="@Model.Quantity" Min="1f"
                                                   ValueChanged="@(async (float d) => await OnQuantityInputValueChangedAsync(d))">
                            </AntDesign.InputNumber>
                            <span class="align-self-center">@Model.QuantityType.QuantityLabel</span>
                        </div>
                        <div class="d-flex">
                            <Button Class="d-flex align-items-center justify-content-center" Icon="plus"
                                    OnClick="OnIncrementQuantityButtonClickedAsync"></Button>
                            <Button Class="d-flex align-items-center justify-content-center" Icon="minus"
                                    OnClick="OnDecrementQuantityButtonClickedAsync"></Button>
                        </div>
                    </div>
                    @if (Model.IsTemporary)
                    {
                        <div class="px-2 m-0 ml-auto">
                            <Button Icon="download"
                                    OnClick="@OnMakeItemPermanentButtonClicked"
                                    Disabled="@(Model.Id.ActualId == null)">
                            </Button>
                        </div>
                    }
                    else
                    {
                        <div class="px-2 m-0 ml-auto">
                            <Button class="oi-button" OnClick="OnOpenUpdatePriceClicked">
                                <span class="oi oi-dollar"></span>
                            </Button>
                        </div>
                    }
                </div>
            </div>
        </div>
    }
    else
    {
        <div class="d-flex">
            <div class="m-0">
                <span>@Model.Quantity</span><span>@Model.QuantityType.QuantityLabel</span>
            </div>
            <div class="m-0 pl-2">
                @Model.Name
            </div>
            <div class="px-2 m-0 align-self-center ml-auto">
                <span>@($"{CalculatePrice():0.00}")</span>
                <span>€</span>
            </div>
        </div>
    }
</li>
<Modal Title="@GetTitle()"
       Visible="@_updatePriceModalVisible"
       OnCancel="@OnCloseUpdatePriceModalButtonClicked"
       ConfirmLoading="@_modalLoading"
       Footer="@GetFooter()">
    <AntDesign.InputNumber Formatter="FormatUpdatePrice" 
                           Parser="ParseUpdatePrice"
                           Class="price-update-input"
                           @bind-value="@_updatedPricePerQuantity"
                           Min="0.01f"></AntDesign.InputNumber>
    @if (Model.TypeId is not null)
    {
        <div class="pt-3">
            <Checkbox @bind-Checked="@_updatePriceForAllOtherItemTypes">
                Update for all types
            </Checkbox>
        </div>
    }
</Modal>

@code{
    //[Parameter] public ShoppingListState State { get; set; }
    [Parameter] public ShoppingListItem Model { get; set; }

    private bool _updatePriceModalVisible = false;
    private bool _modalLoading = false;
    private float _updatedPricePerQuantity = 0.01f;
    private bool _updatePriceForAllOtherItemTypes = true;

    private async Task OnItemClickedAsync()
    {
        if (State.Value.EditModeActive)
            return;

        if (Model.IsInBasket)
        {
            Dispatcher.Dispatch(new RemoveItemFromBasketAction(Model.Id, Model.TypeId));
            //Model.RemoveFromBasket();
            //await _apiService.RemoveItemFromBasketAsync(State.ShoppingList.Id, Model.Id, Model.TypeId);
        }
        else
        {
            Dispatcher.Dispatch(new PutItemInBasketAction(Model.Id, Model.TypeId));
            //Model.PutInBasket(() => State.StateChanged?.Invoke());
            //await _apiService.PutItemInBasketAsync(State.ShoppingList.Id, Model.Id, Model.TypeId);
        }
        //State.StateChanged?.Invoke();
    }


    private float CalculatePrice()
    {
        return _itemPriceCalculationService.CalculatePrice(Model.QuantityType.Id, Model.PricePerQuantity, Model.Quantity);
    }

    private async Task OnQuantityInputValueChangedAsync(float quantity)
    {
        Dispatcher.Dispatch(new ChangeItemQuantityAction(Model.Id, Model.TypeId, quantity));
        //Model.SetQuantity(quantity);
        //await SendQuantityChangedRequestAsync();
        //State.StateChanged?.Invoke();
    }

    private async Task OnRemoveItemButtonClickedAsync()
    {
        Dispatcher.Dispatch(new RemoveItemFromShoppingListAction(Model.Id, Model.TypeId));
        //State.ShoppingList.Remove(Model.Id, Model.TypeId);
        //await _apiService.RemoveItemFromShoppingListAsync(State.ShoppingList.Id, Model.Id, Model.TypeId);
        //State.StateChanged?.Invoke();
    }

    private async Task OnIncrementQuantityButtonClickedAsync()
    {
        Dispatcher.Dispatch(new ChangeItemQuantityAction(Model.Id, Model.TypeId, Model.QuantityType.DefaultQuantity));
        //Model.ChangeQuantity(Model.QuantityType.DefaultQuantity);
        //await SendQuantityChangedRequestAsync();
        //State.StateChanged?.Invoke();
    }

    private async Task OnDecrementQuantityButtonClickedAsync()
    {
        Dispatcher.Dispatch(new ChangeItemQuantityAction(Model.Id, Model.TypeId, -Model.QuantityType.DefaultQuantity));
        //Model.ChangeQuantity(-Model.QuantityType.DefaultQuantity);
        //await SendQuantityChangedRequestAsync();
        //State.StateChanged?.Invoke();
    }

    //private async Task SendQuantityChangedRequestAsync()
    //{
    //    await _apiService.ChangeItemQuantityOnShoppingListAsync(State.ShoppingList.Id, Model.Id, Model.TypeId, 
    //        Model.Quantity);
    //}

    private void OnMakeItemPermanentButtonClicked()
    {
        _navigationManager.NavigateTo($"items/{Model.Id.ActualId!.Value}");
    }

    private void OnOpenUpdatePriceClicked()
    {
        _updatePriceModalVisible = true;
        _modalLoading = false;
        _updatePriceForAllOtherItemTypes = true;
        _updatedPricePerQuantity = Model.PricePerQuantity;
    }

    private void OnCloseUpdatePriceModalButtonClicked()
    {
        _updatePriceModalVisible = false;
        _modalLoading = false;
    }

    private string GetTitle()
    {
        return $"Update price - {Model.Name}";
    }

    private RenderFragment GetFooter()
    {
        return @<Template>
                   <div class="d-flex">
                       <Button Class="ml-auto"
                               OnClick="OnUpdatePriceButtonClicked"
                               @key="@("submit")"
                               Type="@ButtonType.Primary"
                               Loading="@_modalLoading">
                           Update
                       </Button>
                   </div>
               </Template>;
    }

    private async Task OnUpdatePriceButtonClicked()
    {
        _modalLoading = true;
        var itemTypeId = Model.TypeId is not null && !_updatePriceForAllOtherItemTypes ? Model.TypeId : null;
        await _apiService.UpdateItemPriceAsync(Model.Id.ActualId!.Value, itemTypeId, State.Value.SelectedStoreId,
            _updatedPricePerQuantity, async () =>
            {
                //await State.RequestReloadAsync();
                _updatePriceModalVisible = false;
            });
        _modalLoading = false;
    }

    private string FormatUpdatePrice(float value)
    {
        return $"{value:n2} {Model.QuantityType.PriceLabel}";
    }

    private string ParseUpdatePrice(string value)
    {
        return value.Replace(Model.QuantityType.PriceLabel, string.Empty);
    }
}